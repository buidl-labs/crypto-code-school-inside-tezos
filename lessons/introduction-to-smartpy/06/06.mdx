---
title: Simulating initialization of contract with basic testing
chapter: Chapter 6
slug: chapter-06
filterBy: lesson-1
editor:
  showEditor: true
  language: python
  startingCode: |
    import smartpy as sp

    class Plant(sp.Contract):
        def __init__(self):
            self.init(name = "peashooter")
        
    # Add testing code below


  answer: |  
    import smartpy as sp

    class Plant(sp.Contract):
        def __init__(self):
            self.init(name = "peashooter")
        
    # Add testing code below
    @sp.add_test(name = "Test Plant Contract")
    def test():
        scenario = sp.test_scenario()

        plant_test_contract = Plant()
        
        scenario += plant_test_contract
---

### Intro: 

We know that testing is generally important while writing any kind of code. 

But with smart contracts - whose main use case is found in dealing with exchanging digital value be it in the form of money, property rights, agreements etc - **bugs can result in major loss of funds!**

Examples of bugs in smart contract code that resulted in major loss of funds: 

| Incidence | Loss of funds in $ |
| --------- | -------------- |
| Infamous hack of [The DAO](https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/)      | $150,000,000 |
| [Bug in Parity's Mulit-Sig Wallet exploited](https://cointelegraph.com/news/parity-multisig-wallet-hacked-or-how-come) | $154,000,000 (approx)|
| [dForce smart contracts drained](https://www.coindesk.com/attacker-drains-decentralized-protocol-dforce-of-25m-in-weekend-attack) | $25,000,000|
| [dForce smart contracts drained](https://www.coindesk.com/attacker-drains-decentralized-protocol-dforce-of-25m-in-weekend-attack) | $25,000,000 |
| [bZx smart contracts attacked twice](https://cointelegraph.com/news/decentralized-lending-protocol-bzx-hacked-twice-in-a-matter-of-days) | $954,000  |

![Alt Text](https://media.giphy.com/media/YQitE4YNQNahy/giphy.gif)



Hence writing test code is an extremely crucial skill to learn to prevent hackers exploiting your code. Testing let's you simulate how of your smart contract will behave when finally deployed. 


## Study Time: 

We will learn testing in 3 steps: 

1. First we create a testing environment. 
2. Then we will define a scenario in our newly created testing environment. 
3. Then we will use this scenario to simulate our `Plant` contract's initialization. 

### Show me an example: 

#### Step 1: Creating a test environment: 

A test environment is added at the end of your smart contract's code. 

```python
import smartpy as sp

class Bank(sp.Contract):
   ....
    
@sp.add_test(name = "Test Bank Contract")
def test():
   ....
   
```

Explaining the code above: 

1. We add a `@sp.add_test` decorator with a `name` variable to instruct the compiler that the code block after this will be used for testing. 
2. We then follow it up with `test` function definition that creates our testing environment. 
3. Inside this newly created testing environment, we will be writing the code to test our smart contract. 

#### Step 2: Defining a scenario: 

Think of the times you have run possible simulation of your odds when betting with your friends! 

![Alt Text](https://media.giphy.com/media/BmmfETghGOPrW/giphy.gif)

That's the exact intent behind creating a scenario as it let’s us create a boxed simulation environment where we can tinker with our smart contract!


We add a scenario to our test by doing the following: 

```python
@sp.add_test(name = "Test Bank Contract")
def test():
    scenario = sp.test_scenario()
```

Explaining the code above: 

1. We call `sp.test_scenario` - a functionality offered by the `smartpy` library. 
2. And we store the instance of the test scenario we created into the `scenario` variable. 

#### Step 3: Simulating initialization of contract


```python
@sp.add_test(name = "Test Bank Contract")
def test():
    scenario = sp.test_scenario()
    
    bank_test_contract =  Bank()
    
    scenario += bank_test_contract

```

Explaining the code above: 

1. We need to add our contract to the simulation environment we had created before so that we can tinker with it. 
2. To do the above, we first created a new initialized instance contract from our `Bank` class and stored it in `bank_test_contract`. 
3. Then we add this instance to the scenario to drop our contract inside our simulation environment. 

You can also tinker around with the above code on [SmartPy’s online IDE](https://smartpy.io/demo/index.html?code=eJxtkEtqwzAQhvc@xU@6cSj4AAVDH1coZKlMpTEVtUZGmjS0p68kx00L0WKkef3fjHxYYlLkQEmXL1BGXrrOzpQznkk@@rwML1E0kdX9QwfA8QRjvHg1ps88T2u4nuoNNdMLBcaI3SGm2TWh3X6r2m50j0WcnDPK@dryWpzWgY1bWiu0VV1g2bJQ8rE0FI2aMVuoX0HN3OHAmHwqijYxKYMgfEad0dPsv9mVd1YSy7AXHKYUA@Ip4VjHOKL9xrAqvpVIm9f8lo9Yf@ov90kc9J0FZ4ZLcSmOz1eCF42NkH04zaQ@SlsPLJ8@RQks@n_P@_EG@gq8ZX4An5CSAw--). Try running the test by clicking on the ▶️ button!


### Python concept refresher: 
1. [Python decorators 101](https://realpython.com/primer-on-python-decorators/)


## #buidl-ing time:

Now let us practice what we learned so far on our `Plant` contract: 


1. Add a test with the **name of “Test Plant Contract”** using `@sp.add_test` decorator. 
2. Then follow it up with `test` function whose scope contains your testing code. 
3. Inside `test` function, initialize a test scenario by calling  `sp.test_scenario()` and store it inside a `scenario` variable. 
4. Initialize an instance of the `Plant` contract and store it inside `plant_test_contract`
5. Use the initialized instance of `Plant` stored in `plant_test_contract`  and add it to the scenario created in step 3.


<br />

When you’re finished:

1. Click on “Check” to check your submission with the correct answer.
2. Click on “Show Answer” in case you get stuck.